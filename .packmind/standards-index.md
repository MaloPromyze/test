# Packmind Standards Index

This standards index contains all available coding standards that can be used by AI agents (like Cursor, Claude Code, GitHub Copilot) to find and apply proven practices in coding tasks.

## Available Standards

- [Back-end repositories SQL queries using TypeORM](./standards/back-end-repositories-sql-queries-using-typeorm.md) : Implement SQL query guidelines using TypeORM's QueryBuilder in back-end repositories under /infra/repositories/*Repository.ts to enhance type safety, prevent SQL injection, and improve code maintainability when writing database queries, including lookups, joins, and handling soft-deleted entities.
- [Front-end UI and Design Systems](./standards/front-end-ui-and-design-systems.md) : Adopt guidelines for using Chakra UI v3 through the @packmind/ui design system in React applications to ensure consistent UI implementation and visual consistency, applying this standard when building or modifying any frontend components.
- [Frontend Data Flow](./standards/frontend-data-flow.md) : Apply this standard when building frontend routes with React Router v7 and TanStack Query to ensure consistent data flow patterns and optimal user experience.
- [Frontend Error Management](./standards/frontend-error-management.md) : Establish frontend error management for apps/frontend/**/*.tsx that prescribes when to add React error boundaries beyond the global root.tsx fallback and how to handle errors they don't catch—such as event handlers, async code, SSR, or errors thrown in the boundary—by using TypeScript-typed guards (e.g., isPackmindError), try/catch for async operations, TanStack Query onError callbacks and mutation-pending checks to prevent double submissions, inline validation for expected API/user errors, and selective page- or component-level boundaries for isolated third-party widgets like CodeMirror, to reduce complexity, improve UX, and keep error flows maintainable in React/TypeScript projects built with Node.js and typical tooling (Vite/Webpack, ESLint/Prettier) and tested with Jest/Cypress.
- [Frontend Navigation with React Router](./standards/frontend-navigation-with-react-router.md) : Standardize frontend navigation using React Router v7 with centralized utilities in React applications to ensure consistent URL parameter handling and simplify navigation management, particularly when organizing and scoping URLs, across apps/frontend/**/*.tsx.
- [Frontend Routing and Bundling](./standards/frontend-routing-and-bundling.md) : Configure frontend routing and bundling to ensure React Router v7 routes are correctly grouped and bundled via Vite's rollupOptions.output.manualChunks in apps/frontend/vite.config.ts using id.includes() path matching to emit named chunks (routes-public-auth, routes-org-analytics, routes-org-settings, routes-org-artifacts) for public auth, org analytics/deployments/account settings, org settings, and artifacts to optimize code splitting, minimize bundle sizes, and improve loading performance in TypeScript React applications.
- [Jest Test Suite Organization and Patterns](./standards/jest-test-suite-organization-and-patterns.md) : Establish Jest test suite organization and patterns governing test file structure, describe/it hierarchy, typed mocking using jest.Mocked<ServiceType> and createMockInstance, factory-based test data and @packmind/types createUserId/createOrganizationId/createStandardId helpers, assertion conventions (single primary assertion, .not.toHaveBeenCalled()), test ordering (happy path, error cases, edge cases, complex scenarios), and validation/error-handling patterns for TypeScript/Node.js monorepo code (including Express or frontend React/Vue components where applicable) and toolchains (ESLint, Prettier, Webpack/Vite) with CI/infrastructure considerations (Docker, Kubernetes, AWS) to ensure reliable, maintainable, and debuggable unit and integration tests when writing or refactoring test suites with Jest.
- [Port-Adapter Cross-Domain Integration](./standards/port-adapter-cross-domain-integration.md) : Apply the Port/Adapter pattern to enable cross-domain communication while preventing circular dependencies and maintaining loose coupling in the DDD monorepo.
- [TanStack Query Key Management](./standards/tanstack-query-key-management.md) : Manage TanStack Query key structures using hierarchical prefix matching and dedicated queryKeys.ts files in React applications to ensure efficient cache invalidation and type-safe query management when handling cross-domain data operations.
- [Use Case Architecture Patterns](./standards/use-case-architecture-patterns.md) : Structure use cases in the Packmind monorepo by following hexagonal architecture principles with command/response patterns, specific typing, and separation of concerns for authentication and authorization to ensure consistent, type-safe, and maintainable cross-domain integrations when creating or refactoring use cases.


---

*This standards index was automatically generated from deployed standard versions.*